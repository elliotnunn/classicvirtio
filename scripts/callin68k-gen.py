#!/usr/bin/env python3

# Copyright (c) 2024 Elliot Nunn
# Licensed under the MIT license

import sys
import subprocess
import itertools
import re


def main():
    scriptname = __file__.rpartition("/")[2]
    filename = scriptname.replace("-gen.py", ".h")
    filepath = __file__.rpartition("/")[0].rpartition("/")[0] + "/" + filename

    print(f"Generating {filename}")
    sys.stdout = open(filepath, "w")

    print(f"// Generated by {scriptname} -- do not edit")
    print()
    print("// These macros create externally callable function pointers.")
    print("// All registers are saved across calls, except for D0 by C functions,")
    print("// to enable safe interaction with the lower-level parts of Mac OS.")
    print("// Sadly there need to be 2 versions of each macro:")
    print("// GLOBDEF for global initializers and FUNCDEF to call inside functions.")
    print()
    print("#if GENERATINGCFM // PowerPC NDRV")
    gen_powerpc()
    print("#else // 68k DRVR")
    gen_68k()
    print("#endif")


def gen_powerpc():
    print("// Make Routine Descriptors (68k-executable structs starting with an AAFE trap)")
    print("#include <MixedMode.h>")
    print()

    for sig in allsigs():
        if sig.startswith("C_"):
            expr = 0x31 # kCStackBased | RESULT_SIZE(SIZE_CODE(4))
        else:
            expr = 0 # kPStackBased

        m = re.match(r'.*_ARG(\d+)', sig)
        m = m.group(1)
        if m == '0': m = ''

        if "_RET" in sig:
            expr |= ('0124'.index(sig[-1])) << 4

        shift = 6
        for idx, size in enumerate(m, 1):
            expr |= ('0124'.index(size)) << shift
            shift += 2

        print(f"#define CALLIN68K_{sig}_GLOBDEF(func) ((void *)&(RoutineDescriptor)BUILD_ROUTINE_DESCRIPTOR({expr:#x}, func))")
        print(f"#define CALLIN68K_{sig}_FUNCDEF(func) ({{static RoutineDescriptor D = BUILD_ROUTINE_DESCRIPTOR({expr:#x}, func); (void *)&D;}})")

    print()


def assemble(code):
    code = ".short 0xe110\n" + code + "\n.short 0xe110\n"
    with open("/tmp/callin.a", "w") as f:
        f.write(code)
    subprocess.run(["m68k-apple-macos-as", "-o", "/tmp/callin.o", "/tmp/callin.a"], check=True)
    with open("/tmp/callin.o", "rb") as f:
        code = f.read()
    return code.split(b"\xe1\x10")[1]


def gen_68k():
    thelist = {}

    for narg in range(0, 18, 2):
        thelist[f"C_ARG{narg}"] = cthunk(narg)

    for narg in range(0, 18, 2):
        for nret in [0, 2, 4]:
            thelist[f"PAS_ARG{narg}_RET{nret}"] = pascalthunk(narg, nret)

    needstructs = set()

    print("// Make 68k-executable structs that save, set and restore A5")
    print("extern char __got_start[]; // thanks linker script")
    print()

    for asmsig, asm in thelist.items():
        code = assemble(asm)
        code = code.hex()
        code = re.sub(r"(....)", r"0x\1,", code).rstrip(", ")
        code = re.sub(r"0x(\w)\1\1\1, *0x\1\1\1\1", r"0x\1\1\1\1\1\1\1\1", code)
        structtype = re.sub(r"0x(\w+),? ?", lambda m: str(len(m.group(1)) // 2), code)
        code = code.replace("0xdddddddd", "__got_start")
        code = code.replace("0xcccccccc", "func")

        asm = asm.replace("0xdddddddd", "__got_start")
        asm = asm.replace("0xcccccccc", "func")
        asm = asm.strip()
        asm = "\n".join("// " + l.strip() for l in asm.split("\n"))
        print(asm)

        needstructs.add(structtype)

        for argsig in allsigs():
            if not rightasm(asmsig, argsig): continue

            print(f"#define CALLIN68K_{argsig}_GLOBDEF(func) ((void *)&(struct _68K_{structtype}){{{code}}})")
            print(f"#define CALLIN68K_{argsig}_FUNCDEF(func) ({{static struct _68K_{structtype} S = {{{code}}}; (void *)&S;}})")

        print()

    needstructs = sorted(needstructs, key=lambda x: ((len(x), x)))

    print("// Structs are needed to mix 2-byte 68k opcodes with 4-byte pointers")
    for s in needstructs:
        decl = f""
        curtype = ""

        for i, width in enumerate(s):
            if width != curtype:
                if width == "2":
                    decl += f"; short f{i}"
                elif width == "4":
                    decl += f"; void *f{i}"
            else:
                if width == "2":
                    decl += f",f{i}"
                elif width == "4":
                    decl += f",*f{i}"

            curtype = width

        decl = decl.lstrip("; ") + ";"
        decl = f"struct _68K_{s} {{{decl}}} __attribute__((packed)) __attribute__((aligned(8)));"

        print(decl)

    print()


def rightasm(asmsig, argsig):
    argsig = argsig.replace("1", "2")
    argsig = re.sub(r"\d+", lambda m: str(sum(int(ch) for ch in m.group(0))), argsig)
    return asmsig == argsig


def pascalthunk(argbytes, retbytes):
    asm = "movem.l %d0/%d1/%d2/%a0/%a1/%a5,-(%sp)\n"

    if retbytes == 2:
        asm += "clr.w   -(%sp) /* we're not hackers! */\n"
    elif retbytes == 4:
        asm += "clr.l   -(%sp) /* we're not hackers! */\n"

    if argbytes:
        asm += f"lea     {retbytes+24+4+argbytes}(%sp),%a0\n"
        for i in range(argbytes // 4):
            asm += f"move.l  -(%a0),-(%sp)\n"
        if argbytes % 4:
            asm += f"move.w  -(%a0),-(%sp)\n"

    asm += "move.l  #0xdddddddd,%a5\n"
    asm += "jsr     0xcccccccc\n"

    # Don't trust the postincrement behaviour
    if retbytes == 2:
        asm += f"move.w  (%sp)+,%d0\n"
        asm += f"move.w  %d0,{retbytes+24+4+argbytes}(%sp)\n"
    elif retbytes == 4:
        asm += f"move.l  (%sp)+,%d0\n"
        asm += f"move.l  %d0,{retbytes+24+4+argbytes}(%sp)\n"

    asm += "movem.l (%sp)+,%d0/%d1/%d2/%a0/%a1/%a5\n"

    if argbytes:
        asm += f"rtd     #{argbytes}\n"
    else:
        asm += "rts\n"

    return asm


def cthunk(argbytes):
    asm = "movem.l %d1/%d2/%a0/%a1/%a5,-(%sp)\n"

    if argbytes == 2:
        asm += f"move.w  {20+4}(%sp),-(%sp)\n"
    elif argbytes == 4:
        asm += f"move.l  {20+4}(%sp),-(%sp)\n"
    elif argbytes > 4:
        asm += f"lea     {20+4+argbytes}(%sp),%a0\n"
        for i in range(argbytes // 4):
            asm += f"move.l  -(%a0),-(%sp)\n"
        if argbytes % 4:
            asm += f"move.w  -(%a0),-(%sp)\n"

    asm += "move.l  #0xdddddddd,%a5\n"
    asm += "jsr     0xcccccccc\n"

    if argbytes > 0 and argbytes <= 8:
        asm += f"addq    #{argbytes},%sp\n"
    elif argbytes > 8:
        asm += f"add     #{argbytes},%sp\n"

    asm += "movem.l (%sp)+,%d1/%d2/%a0/%a1/%a5\n"

    asm += "rts\n"

    return asm


# return a sizeable number of strings
def allsigs():
    arg_permutations = list(itertools.chain(*(itertools.product('124', repeat=n) for n in range(5))))
    arg_permutations = [''.join(str(ch) for ch in tpl) for tpl in arg_permutations]

    ret = []

    for a in arg_permutations:
        if a == '': a = '0'
        ret.append(f"C_ARG{a}")

    for a in arg_permutations:
        if a == '': a = '0'
        ret.append(f"PAS_ARG{a}_RET0")
        ret.append(f"PAS_ARG{a}_RET1")
        ret.append(f"PAS_ARG{a}_RET2")
        ret.append(f"PAS_ARG{a}_RET4")

    return ret


if __name__ == "__main__":
    main()
